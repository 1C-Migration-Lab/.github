Ниже приведена последовательная схема «уровней абстракции» при анализе конфигурации 1С (или любого другого языка), начиная от текста кода и заканчивая высокоуровневым «бизнес-моделированием». Каждый следующий уровень строится на основе предыдущего.

---

## 1. Текст кода (Source Code) {#source-code}

- **Что это?**  
  Это «сырые» файлы текстов модулей (например, выгруженные из конфигурации 1С в формат `.bsl`, `.os`, `.xml` и т.д.).  
- **Особенности**  
  - Человекочитаемый вид.  
  - Для машинной обработки обычно предварительно приводим к формату, пригодному для парсинга (чистим лишние данные, выделяем отдельные файлы и т. п.).

**Пример** (фрагмент BSL в CDATA):
```xml
<Объект>
  <![CDATA[
  Процедура ПриЗаписи(Отказ, РежимЗаписи)
      Сумма = 0;
      Для Каждого СтрокаТЧ Из Товары Цикл
          СтрокаТЧ.СуммаСтроки = СтрокаТЧ.Количество * СтрокаТЧ.Цена;
          Сумма = Сумма + СтрокаТЧ.СуммаСтроки;
      КонецЦикла;
      СуммаДокумента = Сумма;
  КонецПроцедуры;
  ]]>
</Объект>
---

## 2. Лексический уровень (Tokens / Лексический анализ) {#lexical-analysis}

- **Что это?**  
  Множество **токенов** — лексических единиц, на которые разбивается исходный текст: ключевые слова, идентификаторы, операторы, числа, строки, и т. п.  
- **Зачем нужно?**  
  - Для упрощения дальнейшего синтаксического анализа.  
  - Лексер «понимает» структуру кода на уровне базовых символов и лексем.  
- **Особенности**  
  - Обычно формируется последовательность объектов вида `(тип_токена, значение, позицияВТексте)`.  
  - Пример: `("Procedure", "Процедура", Строка 10), ("Identifier", "МояПроцедура", Строка 10), ...`.

**Пример** (упрощённая последовательность токенов):
```json
[
  {"type": "ProcedureKeyword", "value": "Процедура"},
  {"type": "Identifier", "value": "ПриЗаписи"},
  {"type": "LeftParen", "value": "("},
  {"type": "Identifier", "value": "Отказ"},
  {"type": "Assignment", "value": "="},
  {"type": "OperatorKeyword", "value": "Для"}
]
```

---

## 3. Синтаксическое дерево (Parse Tree) {#parse-tree}

- **Что это?**  
  На основе токенов строится **дерево разбора** — максимально детализированное «древовидное» представление структуры кода в соответствии с формальной грамматикой языка.  
- **Зачем нужно?**  
  - Позволяет программе «понять», какие конструкции присутствуют в коде (процедуры, циклы, условные операторы и т. п.).  
  - Это ещё не совсем абстрактное дерево, а более низкоуровневое «привязанное к грамматике».
- **Особенности**  
  - В parse tree обычно все синтаксические элементы (включая скобки, разделители) отображаются узлами.  
  - В случае 1С — это могут быть конструкции типа: `Процедура`, `Если`, `Тогда`, `КонецЕсли`, и т. д.

**Пример** (упрощённый):
```
ProcedureNode
 ├─ Keyword "Процедура"
 ├─ Identifier "ПриЗаписи"
 ├─ ParameterList
 ├─ Body (Block)
 │   └─ Operators...
 └─ Keyword "КонецПроцедуры"
```

---

## 4. Абстрактное синтаксическое дерево (AST, Abstract Syntax Tree) {#abstract-syntax-tree}

- **Что это?**  
  **AST** — это «очищенная» от избыточных деталей версия дерева разбора, где уже нет «лишних» технических узлов (например, ключевых слов-концов блоков).  
  Оно отражает **семантику** кода: «есть процедура с такими-то параметрами», «внутри неё цикл For…To…», «здесь ветка If…Else…».  
- **Зачем нужно?**  
  - Удобнее для анализа логики.  
  - Легче модифицировать (рефакторинг), строить контроль потока (control flow graph), определять зависимости (кто вызывает что).  
- **Особенности**  
  - В AST обычно узлы могут быть класса `ProcedureDefinition`, `FunctionCall`, `IfStatement` и т.д.  
  - В 1С — можно встретить узлы: `MethodDeclaration (Server)`, `Call (GlobalContext.Справочники.Номенклатура)`, и т. п.

**Пример** (для процедуры «ПриЗаписи», упрощённо):
```json
{
  "type": "Procedure",
  "name": "ПриЗаписи",
  "params": ["Отказ", "РежимЗаписи"],
  "body": [
    {
      "type": "Assignment",
      "target": "Сумма",
      "expression": 0
    },
    {
      "type": "ForEach",
      "iterator": "СтрокаТЧ",
      "collection": "Товары",
      "body": [
        {
          "type": "Assignment",
          "target": "СтрокаТЧ.СуммаСтроки",
          "expression": {
            "type": "BinaryOp",
            "left": "СтрокаТЧ.Количество",
            "operator": "*",
            "right": "СтрокаТЧ.Цена"
          }
        }
      ]
    }
  ]
}
```

---

## 5. Модель/Представление кода (Code Model / Intermediate Representation) {#code-model}

- **Что это?**  
  Это уровень, на котором мы уже консолидируем все данные о **модулях**, **процедурах**, **функциях**, **переменных**, **объектах** (например, Документах, Справочниках), **вызываемых методах** и т. д.  
  Можно считать это **промежуточным представлением** (IR), в котором каждая сущность 1С имеет свою «программистскую» структуру.  
- **Зачем нужно?**  
  - Для дальнейшего анализа на уровне «модулей», «объектов метаданных», «зависимостей» между процедурами.  
  - Удобно для построения **графа зависимостей** и анализа контрольного потока (CFG).  
- **Особенности**  
  - Здесь мы обычно уже не храним досконально всю грамматику, а оперируем собственными классами-моделями. Например, `МодульОбъекта`, `МодульУправляемойФормы`, `ОбщийМодуль`, `Процедура`, `ВозвращаемоеЗначение` и т. д.  
  - Можем хранить связи: «Из этого метода вызывается такой-то метод другого модуля».

**Пример** (упрощённый JSON для «ЗаказПокупателя»):
```json
{
  "objectType": "Document",
  "name": "ЗаказПокупателя",
  "properties": [
    {"name": "Контрагент", "type": "CatalogRef.Контрагенты"},
    {"name": "СуммаДокумента", "type": "Number"}
  ],
  "tableParts": [
    {
      "name": "Товары",
      "fields": [
        {"name": "Номенклатура", "type": "CatalogRef.Номенклатура"},
        {"name": "Количество", "type": "Number"},
        {"name": "Цена", "type": "Number"},
        {"name": "СуммаСтроки", "type": "Number"}
      ]
    }
  ]
}
```

---

## 6. Уровень зависимостей и связей (Dependency Graph / Cross-Reference Model) {#dependency-graph}

- **Что это?**  
  Построение **графа** зависимостей между элементами кода (процедурами, модулями, объектами метаданных), а также связей с внешним окружением (например, вызовы глобального контекста, обращения к регистрам и т. д.).  
- **Зачем нужно?**  
  - Чтобы отвечать на вопросы типа «Где вызывается данная процедура?», «Откуда идёт изменение регистра?», «Какие объекты участвуют в проведении документа?».  
  - Основы для дальнейших «цепочек» и «инструментов визуализации».  
- **Особенности**  
  - Может храниться в реляционной БД или графовой (Neo4j, ArangoDB) для эффективного обхода.  
  - Обычно каждый узел — это «объект/модуль/процедура», каждое ребро — «вызов», «использование» или «наследование».

**Пример** (упрощённый, в виде списка рёбер):
```
DocumentModule "ЗаказПокупателя.Объект" 
  -> "Движения.ЗаказыПоКонтрагентам" [type="WriteRegister"]
  -> "Справочник.Номенклатура" [type="Reference"]
```

---

## 7. Уровень «архитектуры» / «функциональной модели» {#architecture-level}

- **Что это?**  
  На этом уровне мы начинаем смотреть **не только** на код как «процедуры и вызовы», но и на **объекты метаданных** (справочники, документы, регистры, бизнес-процессы 1С) и **их взаимодействие**.  
- **Зачем нужно?**  
  - Чтобы понять «архитектуру» конфигурации: как разложены подсистемы, какие блоки функционала существуют (CRM, Бухгалтерия, Заработная плата и т. п.).  
  - Связать технические объекты (модули, методы) с **функциональным назначением**: «Это подсистема УправлениеТорговлей, модуль расчёта скидок», «Это ПодсистемаЗарплата, модуль расчёта НДФЛ» и т. п.  
- **Особенности**  
  - Иногда можно автоматически “вычислить” подсистемы по структуре конфигурации.  
  - Часто приходится руками создавать «карты» подсистем (например, названия, описания).  
  - В этом слое уже фигурируют **метаданные** 1С: Документы, РегистрСведений, РегистрНакопления, ПланыОбмена, и т. д.

**Пример**:
```
Подсистема "Управление заказами":
  - Документ "ЗаказПокупателя"
  - Справочник "Номенклатура"
  - Справочник "Контрагенты"
  - Регистр "ЗаказыПоКонтрагентам"
```

---

## 8. Доменная модель (Domain Model) / «Предметная область» {#domain-model}

- **Что это?**  
  Модель, отражающая **предметную область**: какие сущности и процессы (вне 1С, как бизнес-объекты) заложены в конфигурации.  
  Например, «Клиент», «ЗаказПокупателя», «ПоступлениеНаСклад», «ЗарплатныйПроект», «ФондОплатыТруда» и т. п.  
- **Зачем нужно?**  
  - Чтобы люди (аналитики, бизнес-эксперты) могли понять, какие **бизнес-сущности** и **бизнес-процессы** поддерживает конфигурация.  
  - Для системного описания логики в терминах бизнеса (BPMN, UML-диаграммы, ER-модели).  
- **Особенности**  
  - Могут быть «отношения» вроде «Справочник Номенклатура» = бизнес-сущность «Товар», «Документ РеализацияТоваровУслуг» = бизнес-процесс «Продажа» (упрощённо).  
  - Здесь уже высокая степень «семантического» описания: вы знаете не просто «что» вызывается, а **для чего**.

**Пример** (упрощённая ER-модель):
```
Entities:
- Order (id, date, totalAmount, client)
- OrderItem (product, quantity, price, lineAmount)
- Client (id, name, INN)
Relationships:
- Order 1--* OrderItem
- Order *--1 Client
```

---

## 9. Уровень бизнес-процессов и сценариев (Business Processes / BPM) {#business-processes}

- **Что это?**  
  Модель, которая описывает, **как** именно работает бизнес в рамках конфигурации: последовательность действий пользователя, автоматические расчёты, обмен данными, интеграции, регламенты.  
- **Зачем нужно?**  
  - Отвечать на вопросы: «Какие операции по продажам автоматизированы?», «Как проходит согласование счётов?», «Какие шаги в цепочке от Заказа до Реализации?».  
  - Обобщённое понимание, «зачем» нужен каждый документ, справочник, регистр.  
- **Особенности**  
  - Может фиксироваться в виде BPMN-диаграмм, технологических карт, схем взаимодействия подсистем.  
  - Частично это можно извлечь из конфигурации автоматически (особенно если в конфигурации есть объекты «Бизнес-процесс»), но чаще требуется ручная работа аналитика, т. к. «чтение мыслей» конфигурации не всегда возможно.

**Пример** (BPMN-подобно, упрощённо):
```
(Менеджер) -> "Создать документ ЗаказПокупателя" -> "Заполнить ТЧ" -> "Провести (ПриПроведении)" -> (Регистр Обновлён)
```

---

## 10. Уровень «бизнес-модели» (Business Model) {#business-model}

- **Что это?**  
  Конечная, наиболее абстрактная надстройка, где **все** технические детали скрыты, а проектировщики и менеджмент видят систему как набор **бизнес-функций**: «Продажи», «Закупки», «Складской учёт», «Зарплата и Кадры», «Бухучёт», «Отчётность» и т. п.  
- **Зачем нужно?**  
  - Для общения с бизнес-стейкхолдерами: руководство, пользователи, методологи.  
  - Чтобы принимать решения о развитии системы, оптимизации процессов, оценке влияния изменений.  
- **Особенности**  
  - Этот слой часто включает **финансовые**, **коммерческие** или **организационные** аспекты (например, KPI, SLA, ROI от автоматизации).  
  - Здесь технические детали 1С проявляются лишь как «поддерживающие механизмы».

**Пример**:
```
Бизнес-функции:
- Управление заказами клиентов
  - KPI: количество заказов в день
  - KPI: средний чек заказа
  - SLA: время обработки заказа
- Контроль задолженности
  - KPI: процент просроченных оплат
```

---

### Суммируем в виде «пирамиды» снизу вверх

1. **Source Code** (текст кода)  
2. **Lexical Analysis** (Токены)  
3. **Parse Tree** (Дерево разбора)  
4. **AST** (Абстрактное синтаксическое дерево)  
5. **Code Model / IR** (Промежуточное представление кода и объектов)  
6. **Dependency Graph / Cross-Reference** (Граф вызовов, ссылок, зависимостей)  
7. **Архитектурный / Функциональный уровень** (Подсистемы, модули, объекты метаданных)  
8. **Domain Model** (Бизнес-сущности, предметная область)  
9. **Business Processes** (BPM, сценарии, регламенты)  
10. **Business Model** (Верхнеуровневая бизнес-схема, функции, цели, KPI)

---

## Как это используется в «анализаторе 1С»?

1. **Парсер** строит **Parse Tree** и дальше **AST** из текстов модулей.  
2. На основе AST формируете **Code Model**, где есть модули, процедуры, объекты конфигурации (справочники, документы).  
3. Из **Code Model** можно извлечь **Dependency Graph** (кто кого вызывает, какие регистры читаются/пишутся).  
4. Анализируя **метаданные** (подсистемы, иерархии), вы собираете «архитектурный слой»: какие подсистемы, функции и т. д.  
5. Для **доменной модели** (предметной области) и **бизнес-процессов** вы добавляете семантические описания (теги, документирование, бизнес-термины).  
6. На самом верху формируется единая **бизнес-модель**, доступная для «непрограммистов».  

Так достигается полная «сквозная» трассировка от бизнес-процесса в верхнем слое до конкретного модуля и строки кода, который этот процесс обеспечивает.